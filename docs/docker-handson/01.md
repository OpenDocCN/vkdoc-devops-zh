one

在这一章中，我们将介绍 Linux 容器的基础知识。

虚拟化是指创建具有独立操作系统的虚拟机，但是虚拟机上运行的软件的执行与底层硬件资源分离。多个虚拟机也可能共享相同的底层硬件。

运行虚拟化软件的实际机器称为主机，运行在虚拟化软件之上的虚拟机称为客户机。提供虚拟化功能和抽象硬件的软件称为“虚拟机管理程序”或“管理程序”。常见的虚拟机管理程序平台有 VMware、HyperV、Xen 和 KVM。

Docker 致力于一种叫做 Linux 容器的技术。Linux 容器有一种不同于虚拟化的方法；您可以称之为 OS 级虚拟化，这意味着所有的容器都运行在一个 Linux 操作系统之上。

您可以直接在硬件上运行主机操作系统，也可以在虚拟机上运行。每个容器作为一个完全隔离的操作系统运行。

Linux 容器是运行在操作系统之上的轻量级虚拟化系统。它提供了一个几乎类似于标准 Linux 发行版的隔离环境。

Docker 与 LXC 基于容器的虚拟化合作。它也被称为操作系统虚拟化，x86 上最早的容器技术之一实际上是在 FreeBSD 上，以 FreeBSD 监狱的形式出现。

在容器虚拟化中，容器隔离来宾操作系统，但不虚拟化硬件，而不是拥有整个操作系统来宾操作系统。运行容器需要一个打补丁的内核和用户工具，内核提供进程隔离并执行资源管理。因此，所有的容器都运行在同一个内核下，但是它们仍然有自己的文件系统、进程、内存等等。

与虚拟机不同，主机上运行的所有容器都使用相同的内核。此外，启动和停止容器比虚拟机快得多。它提供了一个尽可能接近标准 Linux 发行版的环境。容器从内部看就像一个虚拟机，从外部看就像一堆 Linux 进程。

借助基于容器的虚拟化，使用容器模板即可完成客户操作系统的安装。

在容器方法中，人们通常局限于单个操作系统，因此不能同时运行 Linux 和 windows。

与虚拟化相比，在性能和可伸缩性方面，使用容器有很多优点。如果您打算用一个特定的操作系统运行数百个客户机，基于容器的解决方案会很好地工作，因为它们的开销较小。与虚拟化相比，容器方法中可用的虚拟机数量要多得多，因为资源可供应用程序使用，而不是由主机上运行的多个来宾操作系统实例消耗。

容器比虚拟机弱的一个方面是隔离。虚拟机可以利用 ring -1 [硬件隔离](https://en.wikipedia.org/wiki/X86_virtualization#Hardware-assisted_virtualization)，例如英特尔的 VT-d 和 VT-x 技术提供的硬件隔离。这种隔离可以防止虚拟机“爆发”和相互干扰。容器还没有任何形式的硬件隔离，这使得它们容易被利用。

Docker 在虚拟机中运行良好，这使得它可以在现有的虚拟基础架构、私有云和公共云上使用。因此，虚拟化和容器化将共存，未来可能会有一种混合方法，提供一种统一的方式来利用和管理虚拟化和容器化。

![](../images/00006.jpeg)

图 1-1: Linux 容器

容器基于进程级虚拟化的概念工作。进程级虚拟化已经被 Solaris zones 和 BSD jails 等技术使用了多年。但是这些系统的缺点是需要定制内核，不能在主流内核上运行。与 Solaris zones 和 BSD rails 相反，LXC 容器近年来越来越受欢迎，因为它们可以在任何 Linux 平台上运行。这导致各种基于云的托管服务采用容器化。

如果您研究基于 Linux 的容器，会发现其中涉及到两个主要概念，

1.  命名空间和
2.  控制组。)

![](../images/00007.jpeg)

图 1-2:名称空间和 Cgroups

在 Linux 中，有六种命名空间可以为 Linux 资源提供进程级隔离。名称空间确保每个容器只能看到自己的环境，不会影响或访问其他容器中运行的进程。此外，通过为容器提供目录结构，名称空间提供了对 chroot 等文件系统的受限访问。

容器只能看到那个目录结构，不能访问它上面的任何级别。名称空间还允许容器拥有自己的网络设备，因此每个容器都可以拥有自己的 IP 地址和主机名。这使得每个容器彼此独立运行。让我们详细看看每个名称空间。

Pid 命名空间

这个名称空间被认为是容器中最重要的隔离因素。每个 pid 名称空间都有自己的层次结构，并且会被内核跟踪。另一个重要特征是父 pid 可以控制子 pid，但是子 pid 不能发信号或控制父 pid。

假设我们有十个子 pid，它们有不同的系统调用，这些 pid 只在父名称空间中有意义。它在其父命名空间之外没有控制权。因此，每个隔离的 pid 名称空间将运行一个容器，当容器迁移到另一个主机时，子 pid 将保持不变。

Net 命名空间

这个名称空间用于控制网络。每个网络命名空间都可以有自己的网络接口。假设我们有两个运行两个不同 pid 名称空间的容器，我们希望在这些容器上运行两个不同的 Nginx 服务器实例。这可以通过网络命名空间来实现，因为每个网络命名空间将包含其自己的网络接口，该网络接口连接到以太网桥，用于容器和主机之间的连接。

Ipc 名称空间

这个名称空间隔离了进程间的通信。

Mnt 名称空间

这个名称空间隔离了一组进程的文件系统挂载点。它更像是一个高级安全的 chroot 选项。挂载到特定 mnt 命名空间的文件系统，只能由与之关联的进程访问。

Uts 名称空间

此命名空间为主机名和 NIS 域名提供了隔离。这对于脚本基于这些名称初始化和配置操作非常有用。当在容器中更改主机名时，它只更改与该名称空间关联的进程的主机名。

用户名称空间

这个名称空间隔离了用户和组 ID 名称空间。用户名称空间允许用户和组 id 的每个名称空间的映射。这意味着用户名称空间内的进程的用户和组 id 将不同于名称空间外的 id。

此外，一个进程可以在名称空间之外拥有一个非零的用户 ID，同时在名称空间之内拥有一个为零的用户 ID；换句话说，在它的用户名称空间之外，所有的进程都将拥有操作的非特权访问权。

Cgroups(控制组)是 Linux 内核的一个特性，用于计算、限制和隔离资源。它提供了限制进程可以使用的资源的方法。例如，您可以限制 apache web 服务器或 MySQL 数据库只使用一定数量的磁盘 IO。

因此，Linux 容器基本上是一个进程或一组进程，可以在主机系统上的隔离环境中运行。

在进入 Docker 之前，让我们了解容器的另一个重要方面“写时复制文件系统”。

在 ext4 这样的普通文件系统中，所有新数据都将被覆盖在现有数据之上，并创建一个新副本。与其他 Linux 文件系统不同，写时拷贝文件系统从不覆盖实时数据，而是使用写时拷贝功能(COW)使用磁盘中现有的未使用数据块进行所有更新。只有当所有数据都更新到磁盘时，新数据才是活动的。

例如，考虑数据如何存储在文件系统中。文件系统被划分为若干个块，比如说 16 个块。所以每个 innode 将有 16 个指向块的指针。如果存储的文件少于 16 个块，innode 将直接指向该块。如果数据超过 16 个数据块，16 个数据块将成为指向更多数据块的指针，从而创建一个间接指针。

![](../images/00008.jpeg)

图 1-3:写入时复制

当您修改现有数据时，它将被写入文件系统中未使用的数据块，原始数据保持不变。为了指向新的数据块，必须修改所有间接块指针。但是文件系统将复制所有现有的指针来修改副本。然后，文件系统将通过修改副本来引用新的间接指针块，从而再次更新 innode。修改完成后，指向原始数据的指针保持不变，而更新后的数据将有一组新的指针、块和节点。

![](../images/00009.jpeg)

图 1-4:写入时复制机制

Docker 使用的文件系统之一是 BTRFS。当多个任务使用相同的数据时，使用写入时复制(COW)来处理资源。当应用程序从文件中请求数据时，数据被发送到内存或缓存中。各个应用程序都有自己的内存空间。在多个应用程序请求相同数据的情况下，COW 只允许一个内存空间，并且所有应用程序都指向这个内存空间。正在改变数据的应用程序被给予其自己的存储空间，其中具有新的更新信息。其他应用程序继续对原始数据使用旧指针。

BTRFS 还使用文件系统级快照来实现层。快照是文件系统状态的只读时间点副本。存储快照是使用分配给它的预先指定的空间创建的。每当创建快照时，与原始数据相关联的元数据都存储为副本。元数据是提供关于存储在磁盘中的数据的完整信息的数据。此外，快照不会创建物理拷贝，快照的创建几乎是即时的。未来对原始数据的写入将被记录下来，快照会谨慎地跟踪发生变化的数据块。写入时拷贝的任务是在写入数据块之前，将原始数据块传输到快照存储。这又使得数据在基于时间的快照中保持一致。

对未更改数据快照的任何“读取请求”都会反映到原始卷。只有在请求与更改的数据相关的情况下，请求才会被定向到“复制的”数据块。快照维护元数据，其中包含与数据块相关的报告，这些数据块自上次执行快照以来已经更新。必须注意，数据块仅在第一次写入实例的基础上一次拷贝到快照中

![](../images/00010.jpeg)

图 1-5:奶牛图像快照

写入时复制技术的主要优点之一是其空间效率。这是因为创建快照所需的空间很小，因为它仅保存正在更新的数据，而且，只有当原始拷贝可用时，数据才被视为有效。原始数据卷的性能多少会受到快照的写入时复制技术的影响，因为对数据块的写入请求只能在原始数据被“复制”到快照时执行。当数据保持不变时，读取请求会转移到原始卷。